---
title: "Rustã§USB Mass Storage Class Bulk-Only Transportã‚’å®Ÿè£…ã™ã‚‹"
emoji: "ğŸ£"
type: "tech"
topics: ["Rust", "USB", "Embedded", "raspberrypi", "Driver"]
published: true
published_at: 2024-09-17 00:00
---

æ²é¡Œã®é€šã‚Š Rust ã§ USB Mass Storage Class (MSC) Bulk-Only Transport ã‚’å®Ÿè£…ã—ãŸã€‚
RAM ä¸Šã®å€¤ã‚’ Disk Drive ã«è¦‹ã›ã‹ã‘ãŸãƒ‡ãƒã‚¤ã‚¹ã¨ã—ã¦ Windows ã‹ã‚‰èªè­˜ã§ãã‚‹ã‚ˆã†ã«ãªã£ãŸã®ã§è¦æ‰€ã‚’æ›¸ãæ®‹ã™ã€‚

å®Ÿè£…ã«ã¯ Rust ã‚’ä½¿ç”¨ã—ã€ Raspberry pi pico (rp2040) ä¸Šã§å‹•ä½œç¢ºèªã‚’è¡Œã£ã¦ã„ã‚‹ã€‚å®Ÿè£…ã® Framework ã«ã¯ [embassy-rs](https://github.com/embassy-rs/embassy) ã‚’ä½¿ç”¨ã—ãŸã€‚

## USB é€šä¿¡ã®æ§‹æˆãƒ»è¨­å®š

[Mass Storage Bulk Only 1.0 - usb.org](https://www.usb.org/sites/default/files/usbmassbulk_10.pdf) ã«åŸºã¥ã„ã¦å®Ÿè£…ã™ã‚‹ã€‚å…·ä½“çš„ã«ä»¥ä¸‹ã®é€šä¿¡ã‚’è¡Œã†ã€‚

![usb-config.png](/images/a57b29bd9acd84/usb-config.png)

### Descriptor æ§‹æˆ

- USB Device
  - Device Descriptor (MSC Bulk Only Transport)
  - Configuration Descriptor
    - Interface Descriptor0 (MSC Bulk Only Transport)
      - Endpoint Descriptor1: Bulk out
      - Endpoint Descriptor2: Bulk in

### USB Mass Storage Class

USBï¼ˆã«é™ã‚‰ãªã„è©±ã ãŒï¼‰ã‚’ç”¨ã„ãŸé€šä¿¡ã¯ Host/Device åŒæ–¹ã® FW ã§å…±é€šã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«å®šç¾©ã«åŸºã¥ã„ãŸå®Ÿè£…ãŒå¿…è¦ã ãŒã€ä¸€èˆ¬çš„ã«ä½¿ã‚ã‚Œã‚‹æ©Ÿèƒ½ã«ã¤ã„ã¦ã¯ USB ã®ä»•æ§˜ã¨ã—ã¦ã‚¯ãƒ©ã‚¹å®šç¾©ã•ã‚Œã¦ã„ã‚‹ã€‚
:::message
ä¾‹: ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ»ãƒã‚¦ã‚¹ç­‰å…¥åŠ›ãƒ‡ãƒã‚¤ã‚¹å®šç¾© [Device Class Definition for Human Interface Devices(HID)](https://usb.org/sites/default/files/hid1_11.pdf)
:::

ä»Šæ—¥ä½¿ã‚ã‚Œã¦ã„ã‚‹ OS ã§ USB ãŒä½¿ãˆã‚‹ç’°å¢ƒã«ã‚ã‚Œã°ã€Host å´ã®ãƒ‰ãƒ©ã‚¤ãƒå®Ÿè£…ã¯å¤šãã®å ´åˆç”¨æ„ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ç‹¬è‡ªã®ãƒ‰ãƒ©ã‚¤ãƒä½œæˆã¨ç½²åãƒ»ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã®æ‰‹é †ã‚’çœãã“ã¨ãŒã§ãã‚‹ã€‚
é–‹ç™ºè€…ã¯ Device å´ã® FW ã‚’å®šç¾©ã«åŸºã¥ã„ã¦å®Ÿè£…ã™ã‚‹ã ã‘ã§è‰¯ã„ã€‚

ã“ã®ã‚¯ãƒ©ã‚¹å®šç¾©ã®ã†ã¡ã€å¤–ä»˜ã‘è¨˜æ†¶è£…ç½®ã‚’åˆ¶å¾¡ã™ã‚‹ãŸã‚ã® 1 ã¤ã¨ã—ã¦ MSC ãŒã‚ã‚‹ã€‚

### USB ã®è»¢é€æ–¹æ³•

Bulk-only Transfer ã®å‰ã« Bulk è»¢é€ã«ã¤ã„ã¦è§¦ã‚Œã¦ãŠãã€‚USB ã®è»¢é€æ–¹æ³•ã«ã¯ä¸»ã«ä»¥ä¸‹ã® 4 ç¨®é¡ãŒã‚ã‚Šã€ç”¨é€”æ¬¡ç¬¬ã§ä½¿ã„åˆ†ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã€‚

- Control Transfer
  - ãƒ‡ãƒã‚¤ã‚¹ã®è¨­å®šãƒ»åˆ¶å¾¡ãƒ»å°‘é‡ã®ãƒ‡ãƒ¼ã‚¿è»¢é€ã‚’è¡Œã„å ´åˆ
- Bulk Transfer
  - å¤§é‡ã®ãƒ‡ãƒ¼ã‚¿ã‚’è»¢é€ã™ã‚‹å ´åˆ
- Interrupt Transfer
  - å®šæœŸçš„ã€å³æ™‚é€šçŸ¥ãŒå¿…è¦ãªå ´åˆ
- Isochronous Transfer
  - Audio/Video ç­‰ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§ãŒæ±‚ã‚ã‚‰ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿è»¢é€ã‚’è¡Œã†å ´åˆ

ã¾ãŸ 1 ã¤ã® USB Device ã¯è«–ç†çš„ã«è¤‡æ•°ã®æ©Ÿèƒ½ã‚’ã‚‚ãŸã›ã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚ã“ã®åˆ†å‰²å˜ä½ã‚’ Interface ã¨å‘¼ã¶ã€‚
Interface ãŒå®Ÿè£…ã—ã¦ã„ã‚‹æ©Ÿèƒ½æ¬¡ç¬¬ã§è»¢é€ã«å¿…è¦ãªç·šè·¯ã®ç¨®é¡ã¨æ•°ãŒç•°ãªã£ã¦ãŠã‚Šã€ã“ã®è»¢é€ã®æœ€å°å˜ä½ã‚’ EndPoint ã¨å‘¼ã¶ã€‚

- Device Descriptor
  - Class/SubClass/Protocol code (æ¬¡é …å‚ç…§), VID,PID, è£½é€ å…ƒã€è£½å“åã€ã‚·ãƒªã‚¢ãƒ«ãƒŠãƒ³ãƒãƒ¼ãªã©ãƒ‡ãƒã‚¤ã‚¹è‡ªèº«ã®æƒ…å ±
- Configuration Descriptor
  - Interface Descriptor
    - å¯¾è±¡ã®æ©Ÿèƒ½ãŒå¿…è¦ã¨ã™ã‚‹é€šä¿¡æ¬¡ç¬¬ã§è¤‡æ•°æŒã¦ã‚‹
    - Endpoint Descriptor
      - è»¢é€æ–¹æ³•(Control/Bulk/Interrupt/Isochronous) ã€è»¢é€æ–¹å‘ (IN/OUT)ã€PacketSize ãªã©
      - Interface ãŒå¿…è¦ãª Endpoint ã®æ•°ã ã‘è¤‡æ•°æŒã¦ã‚‹

### Bulk-only Transfer

USB ã®ã‚¯ãƒ©ã‚¹å®šç¾©ã¯ åŒã˜ MSC ã§ã‚‚ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã€ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ç´°åˆ†åŒ–ã•ã‚Œã‚‹ã€‚
ã©ã®ã‚ˆã†ãªè»¢é€æ–¹æ³•ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ã©ã®ã‚ˆã†ãªã‚³ãƒãƒ³ãƒ‰ã‚»ãƒƒãƒˆã§é€šä¿¡ã™ã‚‹ã‹ã‚’è¨­å®šå€¤ (Device Descriptor) ã‚’ Host ã«å ±å‘Šã™ã‚‹ã€‚

MSC Bulk-only Transfer ã¯å¤ªå­—ã®è¨­å®šã‚’å ±å‘Šã™ã‚‹ã€‚æ³¨æ„ç‚¹ã¨ã—ã¦ã€Bulk-only transport ã¨ã„ã†åå‰ã§ã¯ã‚ã‚‹ãŒã€ä¸€éƒ¨ã®è¦æ±‚ã¯ Control è»¢é€ã‚’ç”¨ã„ã¦è¦æ±‚ã•ã‚Œã‚‹ã®ã§ã“ã‚Œã«ã‚‚åå¿œã§ãã‚‹å¿…è¦ãŒã‚ã‚‹ã€‚
:::message
Class Request ã¨å‘¼ã°ã‚Œã€EndPoint 0 ç•ªç›® ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ EndPoint 0 ã¯å¸¸ã« Control è»¢é€ã«å›ºå®šã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Interface Descriptor > Endpoint Descriptor ã§å ±å‘Šã™ã‚‹å¿…è¦ã¯ãªã„ã€‚
0 ç•ªç›®ã«å­˜åœ¨ã™ã‚‹ã®ã¯ã€Descriptor è‡ªä½“ã®èª­ã¿å–ã‚Šã‚„åˆæœŸè¨­å®šãªã©åŸºæœ¬çš„ãªé€šä¿¡ã§ä½¿ç”¨ã™ã‚‹ãŸã‚ã€‚
:::

- Class
  - **Mass Storage Class**
- SubClass
  - **SubClass: SCSI transport command set**
  - SubClass: ATAPI command set
  - SubClass: UFI (USB Floppy Interface) command set
- Protocol
  - **[Bulk-Only Transport](https://www.usb.org/sites/default/files/usbmassbulk_10.pdf)**
  - [Control/Bulk/Interrupt Transport](https://usb.org/sites/default/files/usb_msc_cbi_1.1.pdf)

## ã‚³ãƒãƒ³ãƒ‰è§£é‡ˆ

### Command/Data/Status Protocol

MSC Bulk-only Transfer ã¯ Class Request ã‚’é™¤ãã€Bulk in/out ã® Endpoint ã ã‘ã‚’ç”¨ã„ã¦é€šä¿¡ã‚’è¡Œã†ã€‚

- Command Block Wrapper (CBW):

  - ãƒ›ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒã‚¤ã‚¹ã«é€ä¿¡ã•ã‚Œã‚‹ã‚³ãƒãƒ³ãƒ‰ãƒ‘ã‚±ãƒƒãƒˆã§ã€ãƒ‡ãƒã‚¤ã‚¹ã«å¯¾ã—ã¦å®Ÿè¡Œã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’æŒ‡å®š
  - CBW ã¯ä»¥ä¸‹ã®ã‚ˆã†ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¨ãªã£ã¦ãŠã‚Šã€CBWCD ã«æœ¬å‘½ã®ã‚³ãƒãƒ³ãƒ‰ãŒæ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã€‚

    | ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å           | ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆ) | èª¬æ˜                                                                                 |
    | ---------------------- | --------------- | ------------------------------------------------------------------------------------ |
    | dCBWSignature          | 4               | å›ºå®šå€¤ `0x43425355`                                                                  |
    | dCBWTag                | 4               | ãƒ›ã‚¹ãƒˆãŒè¨­å®šã™ã‚‹ã‚¿ã‚°ã€‚CSW ã§åŒã˜å€¤ã‚’è¿”ã™                                             |
    | dCBWDataTransferLength | 4               | è»¢é€ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆæ•°                                                             |
    | bmCBWFlags             | 1               | ãƒ‡ãƒ¼ã‚¿è»¢é€ã®æ–¹å‘ (0x80: DataIn ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ãƒ›ã‚¹ãƒˆ, 0x00: DataOut ãƒ›ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒã‚¤ã‚¹) |
    | bCBWLUN                | 1               | è«–ç†ãƒ¦ãƒ‹ãƒƒãƒˆç•ªå· (LUN)                                                               |
    | bCBWCBLength           | 1               | CBWCB ã®é•·ã• (1ã€œ16 ãƒã‚¤ãƒˆ)                                                          |
    | CBWCB                  | 16              | ã‚³ãƒãƒ³ãƒ‰ãƒ–ãƒ­ãƒƒã‚¯ (SCSI ã‚³ãƒãƒ³ãƒ‰ãªã©)                                                 |

- DataOut
  - ãƒ›ã‚¹ãƒˆã‹ã‚‰ãƒ‡ãƒã‚¤ã‚¹ã«é€ä¿¡ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã§ã€æ›¸ãè¾¼ã‚€ãƒ‡ãƒ¼ã‚¿ãªã©
- DataIn
  - ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ãƒ›ã‚¹ãƒˆã«é€ä¿¡ã•ã‚Œã‚‹ãƒ‡ãƒ¼ã‚¿ã§ã€èª­ã¿å–ã£ãŸãƒ‡ãƒ¼ã‚¿ãªã©
- Command Status Wrapper (CSW)

  - ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ãƒ›ã‚¹ãƒˆã«é€ä¿¡ã•ã‚Œã‚‹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ‘ã‚±ãƒƒãƒˆã§ã€å®Ÿè¡Œçµæœã‚’ãƒ›ã‚¹ãƒˆã«é€šçŸ¥ã™ã‚‹

    | ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å    | ã‚µã‚¤ã‚º (ãƒã‚¤ãƒˆ) | èª¬æ˜                                                           |
    | --------------- | --------------- | -------------------------------------------------------------- |
    | dCSWSignature   | 4               | å›ºå®šå€¤ `0x53425355`                                            |
    | dCSWTag         | 4               | å¯¾å¿œã™ã‚‹ CBW ã® dCBWTag ã¨åŒã˜å€¤                               |
    | dCSWDataResidue | 4               | å®Ÿéš›ã«è»¢é€ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿é‡ã¨æœŸå¾…ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿é‡ã®å·®               |
    | bCSWStatus      | 1               | ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œçµæœ (0x00: æˆåŠŸ, 0x01: å¤±æ•—, 0x02: Phase Error) |

DataOut ãŒå¿…è¦ãªå ´åˆã€DataIn ãŒå¿…è¦ãªå ´åˆã€ã©ã¡ã‚‰ã‚‚ä¸è¦ãªå ´åˆã® 3 ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒæœ‰ã‚Šã€ä»¥ä¸‹ã®ã‚ˆã†ãªã‚„ã‚Šå–ã‚Šã¨ãªã‚‹ã€‚

#### DataOut ãŒå¿…è¦ãªã‚³ãƒãƒ³ãƒ‰ (Write ç­‰)

```mermaid
sequenceDiagram
    participant Host
    participant Device

    Host->>Device: CBW (Command Block Wrapper)
    loop å¿…è¦ãƒ‡ãƒ¼ã‚¿åˆ†
      Host->>Device: Data-Out
    end

    Device->>Host: CSW (Command Status Wrapper)
```

#### DataIn ãŒå¿…è¦ãªã‚³ãƒãƒ³ãƒ‰ (Read ç­‰)

```mermaid
sequenceDiagram
    participant Host
    participant Device

    Host->>Device: CBW (Command Block Wrapper)
    loop å¿…è¦ãƒ‡ãƒ¼ã‚¿åˆ†
      Device-->>Host: Data-In
    end

    Device->>Host: CSW (Command Status Wrapper)
```

#### DataOut/DataIn ã©ã¡ã‚‰ã‚‚ä¸è¦ãªå ´åˆ

```mermaid
sequenceDiagram
    participant Host
    participant Device

    Host->>Device: CBW (Command Block Wrapper)
    Device->>Host: CSW (Command Status Wrapper)
```

### SCSI Command set

usb.org ã®ä»•æ§˜æ›¸ã‚’è¦‹ã¦ã„ã‚‹ã¨ã€CBW/CSW ã®èª¬æ˜ãŒã‚ã‚‹ãŒå…·ä½“çš„ãªã‚³ãƒãƒ³ãƒ‰ã‚»ãƒƒãƒˆè¨˜è¿°ãŒãªã„ã“ã¨ã«æ°—ãŒã¤ãã€‚ã“ã‚Œã¯ SubClass ã§è¡¨æ˜ã—ã¦ã„ã‚‹å†…å®¹ã§å¤‰åŒ–ã™ã‚‹ãŸã‚ã§ã‚ã‚‹ã€‚
ä»Šå›ã®å ´åˆ SCSI transport command set ãŒã“ã‚Œã«å½“ãŸã‚‹ãŒã€ æ®‹å¿µãªãŒã‚‰ [t10.org](https://www.t10.org/drafts.htm), [INCITS.org](https://www.incits.org/) ã¯å§”å“¡ã‚‚ã—ãã¯è³¼å…¥ã—ãªã„ã¨æ­£å¼ãªã‚‚ã®ã¯è¦‹ã‚‹ã“ã¨ãŒã§ããªã„ã€‚

ä»Šå›ã¯ Hobby ç”¨é€”ãªã®ã§ã€æœªå®Ÿè£…ã® CBW ã‚’ã™ã¹ã¦ã‚¨ãƒ©ãƒ¼å¿œç­”ã—ã¤ã¤ã€ãã®ã‚³ãƒãƒ³ãƒ‰å†…å®¹ã‚’å‡ºåŠ›ã—ã¦ Windows ãŒè¦æ±‚ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã‚’é †ã« debug print/Wireshark ã§ç¢ºèªã—ãŸã€‚
ãã®å¾Œã€1 æ¬¡ã‚½ãƒ¼ã‚¹ã§ã¯ãªã„ãŒç¶²ç¾…çš„ã«ã‚³ãƒãƒ³ãƒ‰ã‚»ãƒƒãƒˆã®æƒ…å ±ãŒå¾—ã‚‰ã‚Œã‚‹æƒ…å ±ã‚’ã„ãã¤ã‹ç¢ºèªã—ãªãŒã‚‰å®Ÿè£…ã‚’ç¹°ã‚Šè¿”ã—ãŸã€‚

æ³¨æ„ç‚¹ã ãŒã€CBW/CSW ç­‰ USB ã®ä»•æ§˜ã«åŸºã¥ãå†…å®¹ã¯ Little Endian ã ãŒã€SCSI ã«é–¢ã‚ã‚‹éƒ¨åˆ† (CBWCB ã‚’ Parse ã™ã‚‹ã¨ãã® Format) ã¯ Big Endian ã§ã‚ã‚‹ã€‚æŠ€è¡“çš„èƒŒæ™¯ã«ã‚ˆã‚‹ã‚‚ã®ã ãŒ Parse æ™‚ã«ãƒŸã‚¹ã—ãªã„ã‚ˆã†ã«æ³¨æ„ã—ãŸã„ã€‚

- [SCSI Commands Reference Manual - seagate](https://www.seagate.com/files/staticfiles/support/docs/manual/Interface%20manuals/100293068j.pdf)
- [SCSI Reference - IBM TS3500 Tape Library](https://www.ibm.com/docs/en/ts3500-tape-library?topic=reference-scsi)
- [Storagetek SL150 Modular Tape Library - Oracle](https://docs.oracle.com/en/storage/tape-storage/storagetek-sl150-modular-tape-library/index.html)
- [AN2554 Creating a Multi-LUN USB Mass Storage Class Device Using the MPLAB Harmony USB Device Stack - Microchip](https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ApplicationNotes/ApplicationNotes/00002554A.pdf)
  - ã‚»ãƒƒãƒˆã™ã¹ããƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«æ‚©ã‚“ã ã¨ãã«ä»¥ä¸‹ã‚’è¦‹ã¤ã‘ã¦åŠ©ã‹ã‚Šã¾ã—ãŸ
  - [How to make a USB Mass Storage Device part 1](https://aidanmocke.com/blog/2020/12/30/USB-MSD-1/)

é †ã«å®Ÿè£…ã—ãŸã‚³ãƒãƒ³ãƒ‰ã¨ãã®è¦ç‚¹

- Test Unit Ready
  - ãƒ‡ãƒã‚¤ã‚¹ã®æº–å‚™å®Œäº†ã‚’ç¢ºèªã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã€‚ç‰¹åˆ¥ Setup ã«æ™‚é–“ãŒã‹ã‹ã‚‹å‡¦ç†ãŒãªã‘ã‚Œã° CSW ã æˆåŠŸå¿œç­”
- Request Sense
  - å‰å›ã®ã‚³ãƒãƒ³ãƒ‰ã§ã‚¨ãƒ©ãƒ¼ãŒèµ·ããŸå ´åˆã«ã€ãã®ã‚¨ãƒ©ãƒ¼è©³ç´°ã‚’åé›†ã™ã‚‹ãŸã‚ã®ã‚³ãƒãƒ³ãƒ‰
  - å®Ÿè£…ä¸Šã¯å‰å›ã®ã‚³ãƒãƒ³ãƒ‰ã®çµæœã‚’æŒã£ã¦ãŠãã€ã‚¨ãƒ©ãƒ¼ãŒã‚ã£ãŸå ´åˆã¯å¯¾å¿œã™ã‚‹ã‚¨ãƒ©ãƒ¼å†…å®¹ã‚’ Host ã«é€ä¿¡å¾Œã€CSW ã§æˆåŠŸå¿œç­”
  - ã‚¨ãƒ©ãƒ¼å†…å®¹ã¯ Sense Key, Additional Sense Code (ASC), Additional Sense Code Qualifier (ASCQ) ã§åˆ†é¡ã—ãŸã‚‚ã®ã‚’é€šçŸ¥ã™ã‚‹ [å‚è€ƒ: Oracle ã® docs](https://docs.oracle.com/en/storage/tape-storage/storagetek-sl150-modular-tape-library/slorm/request-sense-03h.html#GUID-9309F2C0-ABF8-470E-AE25-E9535C821B39)
    - ä¾‹ãˆã°ã€æœªå®Ÿè£…ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ä¸æ­£æ‰±ã„ã§å¿œç­”ã™ã‚‹ãªã‚‰ Sense Key = 0x05 (llegal Request), ASC/ASCQ = 0x20/0x00 (Invalid Command)
- Inquiry
  - SCSI Device ã®åŸºæœ¬æƒ…å ±ã‚’å–å¾—ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã€‚Device Descriptor ã¨åŒã˜ãæœ¬ãƒ‡ãƒã‚¤ã‚¹å›ºæœ‰ã®æƒ…å ±ã‚’ Host ã«é€ä¿¡ã—ã¦ã‹ã‚‰ CSW ã§æˆåŠŸå¿œç­”
  - Removable Media Bit (RMB): ãƒªãƒ ãƒ¼ãƒãƒ–ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ãƒ¡ãƒ‡ã‚£ã‚¢ã‚µãƒãƒ¼ãƒˆã€‚1 ã«è¨­å®š
  - Version: æº–æ‹ ã—ã¦ã„ã‚‹ SCSI ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã€‚AN2554 ã«å€£ã£ã¦ 4
  - Response Data Format (RDF): å¿œç­”ãƒ‡ãƒ¼ã‚¿ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒãƒ¼ã‚¸ãƒ§ã‚¤ãƒ³ã€‚AN2554 ã«å€£ã£ã¦ 2
  - Vendor Identification/Product Identification/Product Revision Level: å›ºæœ‰ã®æƒ…å ±ã‚’è¨­å®š
- Read Format Capacities
  - ã‚µãƒãƒ¼ãƒˆã™ã‚‹å®¹é‡ã‚’è¿”ã™ã€‚ãƒªã‚¹ãƒˆæ•°ã¯ 1 ã§ã€RAM ä¸Šã«é…ç½®ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ Logical Block Size (512byte) ã§å‰²ã£ãŸ Block æ•°ã§è¿”ã™
  - Capacity List Length: 1
  - Number of Blocks: ã‚µãƒãƒ¼ãƒˆã™ã‚‹ç· Byte æ•° / 512byte
  - Descriptor Code: 2=Formatted media
  - Block Length: 512byte
- ReadCapacity (10)
  - Read Format Capacities ã¨ä¼¼ã¦ã„ã‚‹ãŒå‰è€…ã¯ã‚µãƒãƒ¼ãƒˆå¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä¸€è¦§ã€‚ReadCapacity ã¯ç¾åœ¨ã®ãƒ‡ãƒã‚¤ã‚¹ã®ç·å®¹é‡ã¨ãƒ–ãƒ­ãƒƒã‚¯ã‚µã‚¤ã‚ºã‚’å–å¾—ã™ã‚‹
  - Last Logical Block Address: ã‚µãƒãƒ¼ãƒˆã™ã‚‹ç¯„å›²ã®æœ€å¾Œã® LBAã€‚ **Read Format Capacities ã® Number of Blocks - 1 ã«ãªã‚‹ç‚¹ã«æ³¨æ„**
  - Block Length: 512byte
- Mode Sense (6)
  - ç¾åœ¨ã®è¨­å®šã‚„å‹•ä½œãƒ¢ãƒ¼ãƒ‰ã‚’å–å¾—ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰ã€‚å¯å¤‰é•·ã ã£ãŸãŸã‚ AN2554 ã‚’å‚è€ƒã«æœ€å°é™ã®å†…å®¹ã‚’å¿œç­”
  - Mode Data Length: 3byte (Block Descriptors/Mode Pages ãªã—)
  - Medium Type: 0
  - Device-Specific Parameter: 0
  - Block Descriptor Length: 0
- Prevent/Allow Medium Removal
  - ãƒªãƒ ãƒ¼ãƒãƒ–ãƒ«ãƒ‡ã‚£ã‚¹ã‚¯ã‚’èª¤ã£ã¦å–ã‚Šå¤–ã•ãªã„ã‚ˆã†ã«ã€å¤–ã—ã¦ã‚ˆã„ã‹ã‚’ Host ã‹ã‚‰é€šçŸ¥ã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
  - ä»Šå›ã¯å¤–ã™ã‚‚ã®ã¯ãªã„ã®ã§ã‚³ãƒãƒ³ãƒ‰ã«ã‚ã‚‹ Prevent ã¯ç„¡è¦–ã—ã¦ CSW ã§å¿œç­”
- Read (10)
  - ã‚³ãƒãƒ³ãƒ‰ã«æŒ‡å®šã•ã‚ŒãŸ Logical Block Address (LBA) ã‹ã‚‰ Transfer Length åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’ Host ã«é€ä¿¡ã—ã¦ã‹ã‚‰ CSW ã§æˆåŠŸå¿œç­”
  - ä»Šå›ä½¿ç”¨ã—ã¦ã„ã‚‹ Raspberry pi pico ã¯ USB Full Speed ã®ãŸã‚ã€USB Max Packet size ãŒ 64byte ã®ãŸã‚ã€1LBA ã‚ãŸã‚Š `512byte/64byte=8å›` è»¢é€ã‚’è¡Œã†
- Write (10)
  - ã‚³ãƒãƒ³ãƒ‰ã«æŒ‡å®šã•ã‚ŒãŸ Logical Block Address (LBA) ã‹ã‚‰ Transfer Length åˆ†ã®ãƒ‡ãƒ¼ã‚¿ãŒ Host ã‹ã‚‰é€ä¿¡ã•ã‚Œã‚‹ã®ã§ã€å†…éƒ¨ã®ãƒ‡ãƒ¼ã‚¿ã‚’é †ã«æ›´æ–°ã—ã¦ã‹ã‚‰ CSW ã§æˆåŠŸå¿œç­”
  - Read (10) ã¨åŒæ§˜ã« 64byte ã«åˆ†å‰²ã•ã‚Œã¦ãã‚‹ã®ã§é€æ¬¡é©ç”¨ã™ã‚‹ã‹ã€Logical block Size åˆ†é›†ã‚ã¦ã‹ã‚‰é©ç”¨ã™ã‚‹

## å®Ÿè£…

embassy ãŒæä¾›ã—ã¦ã„ã‚‹ rp2040 å‘ã‘ã®ã‚µãƒ³ãƒ—ãƒ«ã®ä»¥ä¸‹ã‚’ãƒ™ãƒ¼ã‚¹ã«æ§‹ç¯‰ã—ãŸã€‚

- Control è»¢é€: [usb_raw.rs](https://github.com/embassy-rs/embassy/blob/main/examples/rp/src/bin/usb_raw.rs)
- Bulk è»¢é€: [usb_raw_bulk.rs](https://github.com/embassy-rs/embassy/blob/main/examples/rp/src/bin/usb_raw_bulk.rs)

å¤§ã¾ã‹ãªå®Ÿè£…ç‚¹

- Control è»¢é€ã®ãƒãƒ³ãƒ‰ãƒ© `embassy_usb::Handler` ã‚’å®Ÿè£…ã—ã¤ã¤ã€BulkIn/BulkOut ã® Endpoint ã‚’æŒã¤ãƒ‡ãƒã‚¤ã‚¹ã¨ã—ã¦åˆæœŸåŒ–
- Device Descriptor ã‚’ MSC Bulk-only Transfer ã®å®šç¾©ã«ãªã‚‹ã‚ˆã†ä¿®æ­£
  - Control è»¢é€ã¨ Bulk è»¢é€ã§ç•°ãªã‚‹ Context ã¨ãªã‚‹ãŸã‚ã€Control è»¢é€ã‹ã‚‰ Bulk è»¢é€ã¸ã®é€šçŸ¥ç”¨ã« Channel ã‚’ç”¨æ„
    - Channel: ç•°ãªã‚‹ã‚¹ãƒ¬ãƒƒãƒ‰é–“ã§ãƒ‡ãƒ¼ã‚¿ã‚’é€å—ä¿¡ã™ã‚‹ãŸã‚ã®é€šä¿¡ç·šè·¯
- Bulk è»¢é€ã‹ã‚‰ Read/Write ã®å®Ÿå‡¦ç†ã¯ã€ã‚³ãƒ¼ãƒ‰è‚¥å¤§åŒ–é˜²æ­¢/è²¬å‹™åˆ†å‰²ã®ãŸã‚ Channel ã‚’ç”¨æ„

### Control è»¢é€

- Get Max LUN: 0 å›ºå®šå¿œç­”
- Mass Storage Reset: Channel çµŒç”±ã§ Bulk å‡¦ç†å´ã«é€šçŸ¥

:::details å®Ÿè£…æŠœç²‹

```rust
/// USB Mass Storage Class Control Handler
/// This handler is used to handle the control requests for the Mass Storage Class.
/// It supports the Mass Storage Reset and Get Max LUN requests.
pub struct MscCtrlHandler<'ch> {
    /// Interface Number
    if_num: InterfaceNumber,
    /// Bulk Transfer Request Sender (for Mass Storage Reset)
    bulk_request_sender: DynamicSender<'ch, BulkTransferRequest>,
}

impl<'ch> Handler for MscCtrlHandler<'ch> {
    fn control_out<'a>(&'a mut self, req: Request, buf: &'a [u8]) -> Option<OutResponse> {
        crate::trace!("Got control_out, request={}, buf={:a}", req, buf);
        None
    }

    /// Respond to DeviceToHost control messages, where the host requests some data from us.
    fn control_in<'a>(&'a mut self, req: Request, buf: &'a mut [u8]) -> Option<InResponse<'a>> {
        crate::trace!("Got control_in, request={}", req);

        // requestType: Class/Interface, host->device
        // request: 0xff (Mass Storage Reset), 0xfe (Get Max LUN)

        if req.request_type != RequestType::Class || req.recipient != Recipient::Interface {
            return None;
        }
        match req.request {
            x if x == ClassSpecificRequest::MassStorageReset as u8 => {
                // Mass Storage Reset
                crate::trace!("Mass Storage Reset");
                match self
                    .bulk_request_sender
                    .try_send(BulkTransferRequest::Reset)
                {
                    Ok(_) => Some(InResponse::Accepted(&buf[..0])),
                    Err(_) => Some(InResponse::Rejected),
                }
            }
            x if x == ClassSpecificRequest::GetMaxLun as u8 && req.length == 1 => {
                // Get Max LUN
                crate::trace!("Get Max LUN");
                buf[0] = 0; // Only one LUN supported
                Some(InResponse::Accepted(&buf[..1]))
            }
            _ => {
                crate::warn!("Unsupported request: {}", req.request);
                Some(InResponse::Rejected)
            }
        }
    }
}
```

:::

### Bulk è»¢é€

- SCSI Command å¯¾å¿œ
- Read/Write ã¯ Channel çµŒç”±ã§ãƒ‡ãƒ¼ã‚¿è»¢é€ã‚’å®Ÿæ–½
- Control è»¢é€ã‹ã‚‰ã® Mass Storage Reset ã‚’å—ã‘ãŸã‚‰ã€ç¾åœ¨ã®å‡¦ç†ã‚’ä¸€åº¦æ‰“ã¡åˆ‡ã£ã¦ BulkOut EP å¾…ã¡åˆã‚ã›ã‹ã‚‰

:::details å®Ÿè£…æŠœç²‹

```rust
impl MscBulkHandlerConfig {
    pub fn new(
        vendor_id: [u8; 8],
        product_id: [u8; 16],
        product_revision_level: [u8; 4],
        num_blocks: usize,
        block_size: usize,
    ) -> Self {
        Self {
            vendor_id,
            product_id,
            product_revision_level,
            num_blocks,
            block_size,
        }
    }
}

/// USB Mass Storage Class Bulk Handler
/// This handler is used to handle the bulk transfers for the Mass Storage Class.
pub struct MscBulkHandler<'driver, 'ch, D: Driver<'driver>> {
    /// Bulk Transfer Request Receiver (for Mass Storage Reset)
    ctrl_to_bulk_request_receiver: DynamicReceiver<'ch, BulkTransferRequest>,
    /// Bulk Endpoint Out
    read_ep: Option<<D as Driver<'driver>>::EndpointOut>,
    /// Bulk Endpoint In
    write_ep: Option<<D as Driver<'driver>>::EndpointIn>,

    /// Config
    config: MscBulkHandlerConfig,

    /// Request Read/Write to Internal
    data_request_sender: DynamicSender<'ch, StorageRequest<MscReqTag, USB_LOGICAL_BLOCK_SIZE>>,
    /// Response Read/Write from Internal
    data_response_receiver:
        DynamicReceiver<'ch, StorageResponse<MscReqTag, USB_LOGICAL_BLOCK_SIZE>>,
}

impl<'driver, 'ch, D: Driver<'driver>> MscBulkHandler<'driver, 'ch, D> {
    pub fn new(
        config: MscBulkHandlerConfig,
        ctrl_to_bulk_request_receiver: DynamicReceiver<'ch, BulkTransferRequest>,
        data_request_sender: DynamicSender<'ch, StorageRequest<MscReqTag, USB_LOGICAL_BLOCK_SIZE>>,
        data_response_receiver: DynamicReceiver<
            'ch,
            StorageResponse<MscReqTag, USB_LOGICAL_BLOCK_SIZE>,
        >,
    ) -> Self {
        Self {
            read_ep: None,
            write_ep: None,
            config,
            ctrl_to_bulk_request_receiver,
            data_request_sender,
            data_response_receiver,
        }
    }

    /// Handle response for simple command
    async fn handle_response_single<'a>(
        write_ep: &'a mut <D as Driver<'driver>>::EndpointIn,
        status: CommandBlockStatus,
        write_data: Option<&'a [u8]>,
        cbw_packet: &'a CommandBlockWrapperPacket,
        csw_packet: &'a mut CommandStatusWrapperPacket,
    ) -> Result<(), EndpointError> {
        if let Some(data) = write_data {
            // transfer data
            write_ep.write(data).await?;
            // update csw_packet.data_residue
            if data.len() < cbw_packet.data_transfer_length as usize {
                csw_packet.data_residue =
                    (cbw_packet.data_transfer_length as usize - data.len()) as u32;
            }
        }
        // update csw_packet
        csw_packet.status = status;

        // Status Transport
        let csw_data = csw_packet.to_data();
        crate::trace!("Send CSW: {:#x}", csw_packet);
        write_ep.write(&csw_data).await?;

        Ok(())
    }

    /// Main loop for bulk-only transport
    pub async fn run(&mut self) -> ! {
        crate::assert!(self.read_ep.is_some());
        crate::assert!(self.write_ep.is_some());
        let read_ep = self.read_ep.as_mut().unwrap();
        let write_ep = self.write_ep.as_mut().unwrap();
        'main_loop: loop {
            // EndPointæœ‰åŠ¹å¾…ã¡
            read_ep.wait_enabled().await;
            crate::trace!("Connected");

            // Request Sense Commandã§Error reportingãŒå¿…è¦ãªã®ã§ã€å‰å›ã®æƒ…å ±ã‚’ä¿æŒã—ã¦ãŠã
            let mut latest_sense_data: Option<RequestSenseData> = None;
            // Phase Erroræ™‚ã®å¯¾å¿œç”¨
            let mut phase_error_tag: Option<u32> = None;

            'read_ep_loop: loop {
                // Check if Mass Storage Reset occurred
                if (self.ctrl_to_bulk_request_receiver.try_receive()
                    == Ok(BulkTransferRequest::Reset))
                {
                    crate::trace!("Mass Storage Reset");
                    phase_error_tag = None;
                    break 'read_ep_loop;
                }

                // clear latest sense data
                latest_sense_data = None;

                // Command Transport
                let mut read_buf = [0u8; USB_LOGICAL_BLOCK_SIZE]; // read bufferåˆ†ç¢ºä¿
                let Ok(read_cbw_size) = read_ep.read(&mut read_buf).await else {
                    crate::error!("Read EP Error (CBW)");
                    phase_error_tag = None; // unknown tag
                    latest_sense_data = Some(RequestSenseData::from(
                        SenseKey::IllegalRequest,
                        AdditionalSenseCodeType::IllegalRequestInvalidCommand,
                    ));
                    break 'read_ep_loop;
                };
                let Some(cbw_packet) = CommandBlockWrapperPacket::from_data(&read_buf) else {
                    crate::error!("Invalid CBW: {:#x}", read_buf);
                    phase_error_tag = None; // unknown tag
                    latest_sense_data = Some(RequestSenseData::from(
                        SenseKey::IllegalRequest,
                        AdditionalSenseCodeType::IllegalRequestInvalidCommand,
                    ));
                    break 'read_ep_loop;
                };
                if !cbw_packet.is_valid_signature() {
                    crate::error!("Invalid CBW signature: {:#x}", cbw_packet);
                    phase_error_tag = None; // unknown tag
                    latest_sense_data = Some(RequestSenseData::from(
                        SenseKey::IllegalRequest,
                        AdditionalSenseCodeType::IllegalRequestInParameters,
                    ));
                    break 'read_ep_loop;
                };
                if cbw_packet.command_length == 0 {
                    crate::error!("Invalid CBW command length: {:#x}", cbw_packet);
                    phase_error_tag = None; // unknown tag
                    latest_sense_data = Some(RequestSenseData::from(
                        SenseKey::IllegalRequest,
                        AdditionalSenseCodeType::IllegalRequestInParameters,
                    ));
                    break 'read_ep_loop;
                };

                // Prepare CSW
                let mut csw_packet = CommandStatusWrapperPacket::new();
                csw_packet.tag = cbw_packet.tag;
                csw_packet.data_residue = 0;
                csw_packet.status = CommandBlockStatus::CommandPassed;

                // Parse SCSI Command
                let scsi_commands = cbw_packet.get_commands();
                let scsi_command = scsi_commands[0];
                // ã‚³ãƒãƒ³ãƒ‰ã”ã¨ã«å‡¦ç†
                let send_resp_status: Result<(), EndpointError> = match scsi_command {
                    x if x == ScsiCommand::TestUnitReady as u8 => {
                        crate::trace!("Test Unit Ready");
                        // ã‚«ãƒ¼ãƒ‰ã®æŠœãå·®ã—ãªã©ã¯ãªã„ã®ã§å•é¡Œç„¡ã—ã§å¿œç­”
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            None,
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::Inquiry as u8 => {
                        crate::trace!("Inquiry");
                        // Inquiry data. resp fixed data
                        let inquiry_data = InquiryCommandData::new(
                            self.config.vendor_id,
                            self.config.product_id,
                            self.config.product_revision_level,
                        );

                        let mut write_data = [0u8; INQUIRY_COMMAND_DATA_SIZE];
                        inquiry_data.prepare_to_buf(&mut write_data);
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            Some(&write_data),
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::ReadFormatCapacities as u8 => {
                        crate::trace!("Read Format Capacities");
                        // Read Format Capacities data. resp fixed data
                        let read_format_capacities_data = ReadFormatCapacitiesData::new(
                            self.config.num_blocks as u32,
                            self.config.block_size as u32,
                        );

                        let mut write_data = [0u8; READ_FORMAT_CAPACITIES_DATA_SIZE];
                        read_format_capacities_data.prepare_to_buf(&mut write_data);
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            Some(&write_data),
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::ReadCapacity as u8 => {
                        crate::trace!("Read Capacity");
                        // Read Capacity data. resp fixed data
                        let read_capacity_data = ReadCapacityData::new(
                            (self.config.num_blocks - 1) as u32,
                            self.config.block_size as u32,
                        );

                        let mut write_data = [0u8; READ_CAPACITY_16_DATA_SIZE];
                        read_capacity_data.prepare_to_buf(&mut write_data);
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            Some(&write_data),
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::ModeSense6 as u8 => {
                        crate::trace!("Mode Sense 6");
                        // Mode Sense 6 data. resp fixed data
                        let mode_sense_data = ModeSense6Data::new();

                        let mut write_data = [0u8; MODE_SENSE_6_DATA_SIZE];
                        mode_sense_data.prepare_to_buf(&mut write_data);
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            Some(&write_data),
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::RequestSense as u8 => {
                        // Error reporting
                        if latest_sense_data.is_none() {
                            latest_sense_data = Some(RequestSenseData::from(
                                SenseKey::NoSense,
                                AdditionalSenseCodeType::NoAdditionalSenseInformation,
                            ));
                        }
                        crate::trace!("Request Sense Data: {:#x}", latest_sense_data.unwrap());

                        let mut write_data = [0u8; REQUEST_SENSE_DATA_SIZE];
                        latest_sense_data.unwrap().prepare_to_buf(&mut write_data);
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            Some(&write_data),
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    x if x == ScsiCommand::Read10 as u8 => {
                        // Read 10 data. resp variable data
                        let read10_data = Read10Command::from_data(scsi_commands);
                        crate::trace!("Read 10 Data: {:#x}", read10_data);
                        let transfer_length = read10_data.transfer_length as usize;

                        // TODO: channelã«ç©ºããŒã‚ã‚‹å ´åˆtransfer_lengthåˆ†ã®RequestæŠ•ã’ã‚‹Taskã¨ã€Responseã‚’å—ã‘å–ã‚‹Taskã®joinã«ã™ã‚‹
                        for transfer_index in 0..transfer_length {
                            let lba = read10_data.lba as usize + transfer_index;
                            let req_tag = MscReqTag::new(cbw_packet.tag, transfer_index as u32);
                            let req = StorageRequest::read(req_tag, lba);

                            self.data_request_sender.send(req).await;
                            let resp = self.data_response_receiver.receive().await;

                            // Readå‡¦ç†ä¸­ã«Readä»¥å¤–ã®å¿œç­”ãŒæ¥ãŸå ´åˆã¯å®Ÿè£…ä¸å…·åˆ
                            if resp.message_id != StorageMsgId::Read {
                                crate::unreachable!("Invalid Response: {:#x}", resp);
                            }
                            // Check if the response is valid
                            if (req_tag != resp.req_tag) {
                                crate::error!("Invalid Response: {:#x}", resp);
                                latest_sense_data = Some(RequestSenseData::from(
                                    SenseKey::HardwareError,
                                    AdditionalSenseCodeType::HardwareErrorEmbeddedSoftware,
                                ));
                            }
                            // Check if there is an error
                            if let Some(error) = resp.meta_data {
                                crate::error!("Invalid Response: {:#x}", resp);
                                latest_sense_data =
                                    Some(RequestSenseData::from_data_request_error(error));
                            }

                            // transfer read data
                            let read_data = resp.data.as_ref();
                            for packet_i in 0..USB_PACKET_COUNT_PER_LOGICAL_BLOCK {
                                let start_index = (packet_i * USB_MAX_PACKET_SIZE);
                                let end_index = ((packet_i + 1) * USB_MAX_PACKET_SIZE);
                                // ç¯„å›²ãŒUSB_BLOCK_SIZEã‚’è¶…ãˆãªã„ã‚ˆã†ã«ä¿®æ­£
                                let end_index = end_index.min(USB_LOGICAL_BLOCK_SIZE);

                                // ãƒ‡ãƒ¼ã‚¿ã‚’å–ã‚Šå‡ºã—ã¦å¿œç­”
                                let packet_data = &read_data[start_index..end_index];
                                crate::trace!(
                                    "Send Read Data (LBA: {:#x}, TransferIndex: {:#x}, PacketIndex: {:#x}): {:#x}",
                                    lba, transfer_index, packet_i, packet_data
                                );
                                let Ok(write_resp) = write_ep.write(packet_data).await else {
                                    crate::error!("Write EP Error (Read 10)");
                                    phase_error_tag = Some(cbw_packet.tag);
                                    latest_sense_data = Some(RequestSenseData::from(
                                        SenseKey::IllegalRequest,
                                        AdditionalSenseCodeType::IllegalRequestInvalidCommand,
                                    ));
                                    break 'read_ep_loop;
                                };
                            }
                        }

                        // CSW å¿œç­”
                        csw_packet.status =
                            CommandBlockStatus::from_bool(latest_sense_data.is_none());
                        let transfer_bytes = transfer_length * self.config.block_size;
                        if transfer_bytes < cbw_packet.data_transfer_length as usize {
                            csw_packet.data_residue =
                                (cbw_packet.data_transfer_length as usize - transfer_bytes) as u32;
                        }
                        let csw_data = csw_packet.to_data();
                        crate::trace!("Send CSW: {:#x}", csw_packet);
                        write_ep.write(&csw_data).await
                    }
                    x if x == ScsiCommand::Write10 as u8 => {
                        // Write 10 data. resp variable data
                        let write10_data = Write10Command::from_data(scsi_commands);
                        crate::trace!("Write 10 Data: {:#x}", write10_data);
                        let transfer_length = write10_data.transfer_length as usize;

                        for transfer_index in 0..transfer_length {
                            let lba = write10_data.lba as usize + transfer_index;
                            // packet sizeåˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹
                            let req_tag = MscReqTag::new(cbw_packet.tag, transfer_index as u32);
                            let mut req =
                                StorageRequest::write(req_tag, lba, [0u8; USB_LOGICAL_BLOCK_SIZE]);
                            for packet_i in 0..USB_PACKET_COUNT_PER_LOGICAL_BLOCK {
                                let start_index = (packet_i * USB_MAX_PACKET_SIZE);
                                let end_index = ((packet_i + 1) * USB_MAX_PACKET_SIZE);
                                // ç¯„å›²ãŒUSB_BLOCK_SIZEã‚’è¶…ãˆãªã„ã‚ˆã†ã«ä¿®æ­£
                                let end_index = end_index.min(USB_LOGICAL_BLOCK_SIZE);

                                // ãƒ‡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹
                                let Ok(read_resp) =
                                    read_ep.read(&mut req.data[start_index..end_index]).await
                                else {
                                    crate::error!("Read EP Error (Write 10)");
                                    phase_error_tag = Some(cbw_packet.tag);
                                    latest_sense_data = Some(RequestSenseData::from(
                                        SenseKey::IllegalRequest,
                                        AdditionalSenseCodeType::IllegalRequestInvalidCommand,
                                    ));
                                    break 'read_ep_loop;
                                };
                            }

                            crate::trace!("Send DataRequest: {:#x}", req);
                            self.data_request_sender.send(req).await;

                            let resp = self.data_response_receiver.receive().await;
                            crate::trace!("Receive DataResponse: {:#x}", resp);

                            // Writeå‡¦ç†ä¸­ã«Writeä»¥å¤–ã®å¿œç­”ãŒæ¥ãŸå ´åˆã¯å®Ÿè£…ä¸å…·åˆ
                            if resp.message_id != StorageMsgId::Write {
                                crate::unreachable!("Invalid Response: {:#x}", resp);
                            }

                            // Check if the response is valid
                            if (req_tag != resp.req_tag) {
                                crate::error!("Invalid Response: {:#x}", resp);
                                latest_sense_data = Some(RequestSenseData::from(
                                    SenseKey::HardwareError,
                                    AdditionalSenseCodeType::HardwareErrorEmbeddedSoftware,
                                ));
                            }
                            // Check if there is an error
                            if let Some(error) = resp.meta_data {
                                crate::error!("Invalid Response: {:#x}", resp);
                                latest_sense_data =
                                    Some(RequestSenseData::from_data_request_error(error));
                            }
                        }

                        // CSW å¿œç­”
                        csw_packet.status =
                            CommandBlockStatus::from_bool(latest_sense_data.is_none());
                        let transfer_bytes = transfer_length * self.config.block_size;
                        if transfer_bytes < cbw_packet.data_transfer_length as usize {
                            csw_packet.data_residue =
                                (cbw_packet.data_transfer_length as usize - transfer_bytes) as u32;
                        }
                        let csw_data = csw_packet.to_data();
                        write_ep.write(&csw_data).await
                    }
                    x if x == ScsiCommand::PreventAllowMediumRemoval as u8 => {
                        crate::trace!("Prevent/Allow Medium Removal");
                        // ã‚«ãƒ¼ãƒ‰ã®æŠœãå·®ã—ã‚’è¨±å¯ã™ã‚‹
                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandPassed,
                            None,
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                    _ => {
                        crate::error!("Unsupported Command: {:#x}", scsi_command);
                        // save latest sense data
                        latest_sense_data = Some(RequestSenseData::from(
                            SenseKey::IllegalRequest,
                            AdditionalSenseCodeType::IllegalRequestInvalidCommand,
                        ));

                        Self::handle_response_single(
                            write_ep,
                            CommandBlockStatus::CommandFailed,
                            None,
                            &cbw_packet,
                            &mut csw_packet,
                        )
                        .await
                    }
                };

                // Phase Erroræ™‚ã®å¯¾å¿œ
                if let Err(e) = send_resp_status {
                    crate::error!("Send Response Error: {:?}", e);
                    // Phase Erroræ™‚ã®å¯¾å¿œç”¨ã«tagã‚’ä¿æŒ
                    phase_error_tag = Some(cbw_packet.tag);
                    break 'read_ep_loop;
                }
            }

            // CSW ã§ Phase Error ã‚’è¿”ã™
            if let Some(tag) = phase_error_tag {
                crate::error!("Phase Error Tag: {:#x}", tag);
                let mut csw_packet = CommandStatusWrapperPacket::new();
                csw_packet.tag = tag;
                csw_packet.data_residue = 0;
                csw_packet.status = CommandBlockStatus::PhaseError;
                let csw_data = csw_packet.to_data();
                // å¤±æ•—ã—ã¦ã‚‚ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ç„¡ç†
                write_ep.write(&csw_data).await;
            }
            crate::trace!("Disconnected");
        }
    }
}
```

:::

### USB Setup éƒ¨åˆ†

- Channel åˆ†é›¢ã®é€šã‚Š Control è»¢é€ã¨ Bulk è»¢é€ã§ç®¡ç†æ§‹é€ ã‚’åˆ†ã‘ã¦ã„ã‚‹
- åˆæœŸåŒ–æ™‚ã« Bulk è»¢é€ã«ã¯ Endpoint ã ã‘ã‚’æ¸¡ã—ã¦ã„ã‚‹

:::details å®Ÿè£…æŠœç²‹

```rust

impl<'ch> MscCtrlHandler<'ch> {
    pub fn new(bulk_request_sender: DynamicSender<'ch, BulkTransferRequest>) -> Self {
        Self {
            if_num: InterfaceNumber(0),
            bulk_request_sender,
        }
    }

    pub fn build<'a, 'driver, D: Driver<'driver>>(
        &'ch mut self,
        builder: &mut Builder<'driver, D>,
        config: Config<'ch>,
        bulk_handler: &'a mut MscBulkHandler<'driver, 'ch, D>,
    ) where
        'ch: 'driver,
    {
        // Bulk Only Transport for Mass Storage
        let mut function = builder.function(
            MSC_INTERFACE_CLASS,
            MSC_INTERFACE_SUBCLASS,
            MSC_INTERFACE_PROTOCOL,
        );
        let mut interface = function.interface();
        let mut alt = interface.alt_setting(
            MSC_INTERFACE_CLASS,
            MSC_INTERFACE_SUBCLASS,
            MSC_INTERFACE_PROTOCOL,
            None,
        );
        bulk_handler.read_ep = Some(alt.endpoint_bulk_out(64));
        bulk_handler.write_ep = Some(alt.endpoint_bulk_in(64));

        drop(function);
        builder.handler(self);
    }
}
```

```rust
/// USB Control Transfer and Bulk Transfer Channel
async fn usb_transport_task(driver: Driver<'static, USB>) {
    // wait for StorageHandler to be ready
    crate::info!("Send StorageRequest(Seup) to StorageHandler");
    let num_blocks = setup_storage_request_response_channel(MscReqTag::new(0xaa995566, 0)).await;

    // Create embassy-usb Config
    crate::info!("Setup USB Ctrl/Bulk Endpoint (num_blocks: {})", num_blocks);
    let mut config = create_usb_config();

    // Create USB Handler
    let mut config_descriptor = [0; 256];
    let mut bos_descriptor = [0; 256];
    let mut msos_descriptor = [0; 256];
    let mut control_buf = [0; 64];

    let mut ctrl_handler = MscCtrlHandler::new(CHANNEL_USB_CTRL_TO_USB_BULK.dyn_sender());
    let mut builder = Builder::new(
        driver,
        config,
        &mut config_descriptor,
        &mut bos_descriptor,
        &mut msos_descriptor,
        &mut control_buf,
    );
    let mut bulk_handler = MscBulkHandler::new(
        MscBulkHandlerConfig::new(
            USB_VENDOR_ID,
            USB_PRODUCT_ID,
            USB_PRODUCT_DEVICE_VERSION,
            num_blocks,
            USB_LOGICAL_BLOCK_SIZE,
        ),
        CHANNEL_USB_CTRL_TO_USB_BULK.dyn_receiver(),
        CHANNEL_USB_BULK_TO_STORAGE_REQUEST.dyn_sender(),
        CHANNEL_STORAGE_RESPONSE_TO_USB_BULK.dyn_receiver(),
    );
    ctrl_handler.build(&mut builder, config, &mut bulk_handler);

    // Run USB Handler
    let mut usb = builder.build();
    let usb_fut = usb.run();
    let bulk_fut = bulk_handler.run();

    join(usb_fut, bulk_fut).await;
}
```

:::

### RAM ä¸Šã®ãƒ‡ãƒ¼ã‚¿æ“ä½œ

- Channel çµŒç”±ã§è¦æ±‚ã•ã‚ŒãŸ Read/Write æ“ä½œã‚’å®Ÿè¡Œ
- [tinyusb msc_disk](https://github.com/hathach/tinyusb/blob/master/examples/device/cdc_msc/src/msc_disk.c#L52) ã®ã‚µãƒ³ãƒ—ãƒ«ã‚’å‚è€ƒã«ã€FAT12 Table ã®å†…å®¹ã‚’ RAM ä¸Šã®åˆæœŸå€¤ã«è¨­å®š

:::details å®Ÿè£…æŠœç²‹

```rust
pub struct RamDiskHandler<const LOGICAL_BLOCK_SIZE: usize, const TOTAL_DATA_SIZE: usize> {
    /// Storage on RAM
    data: [u8; TOTAL_DATA_SIZE],
}

impl<const LOGICAL_BLOCK_SIZE: usize, const TOTAL_DATA_SIZE: usize>
    RamDiskHandler<LOGICAL_BLOCK_SIZE, TOTAL_DATA_SIZE>
{
    /// Create a new RamDisk
    pub fn new() -> Self {
        Self {
            data: [0; TOTAL_DATA_SIZE],
        }
    }

    /// Set data to RamDisk
    pub fn set_data<const N: usize>(&mut self, offset_bytes: usize, data: &[u8; N]) {
        self.data[offset_bytes..offset_bytes + N].copy_from_slice(data);
    }

    /// Get data from RamDisk
    pub fn get_data<const N: usize>(&self, offset_bytes: usize) -> &[u8] {
        &self.data[offset_bytes..offset_bytes + N]
    }

    /// Set FAT12 Data to RAM Disk
    /// refs. https://github.com/hathach/tinyusb/blob/master/examples/device/cdc_msc/src/msc_disk.c#L52
    #[rustfmt::skip]
    pub fn set_fat12_sample_data(&mut self) {
        let readme_contents = b"Hello.\n";
        // LBA0: MBR
        self.set_data(
            0,
            &[
            /// |  0|    1|    2|    3|    4|    5|    6|    7|    8|    9|  0xa| 0xb|  0xc|  0xd|  0xe|  0xf|
                0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x35, 0x2E, 0x30, 0x00, 0x02, 0x01, 0x01, 0x00, // 0x00
                0x01, 0x10, 0x00, 0x10, 0x00, 0xF8, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x10
                0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x29, 0x34, 0x12, 0x00, 0x00, b'S', b'a', b'm', b'p', b'l', // 0x20
                b'e', b' ', b' ', b'M', b'S', b'C', 0x46, 0x41, 0x54, 0x31, 0x32, 0x20, 0x20, 0x20, 0x00, 0x00, // 0x30
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x40
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x50
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x60
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x70
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x90
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xa0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xb0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xc0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xd0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xe0
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xaa, // 0xf0
            ],
        );
        // LBA1: FAT12 Table
        self.set_data(512, &[0xF8, 0xFF, 0xFF, 0x00, 0x00]);
        // LBA2: Root Directory
        let flen = (readme_contents.len() - 1) as u8;
        self.set_data(
            1024,
            &[
            /// first entry is volume label
            /// |  0|    1|    2|    3|    4|    5|    6|    7|    8|    9|  0xa| 0xb|  0xc|  0xd|  0xe|  0xf|
                b'S', b'a', b'm', b'p', b'l', b'e', b' ', b' ', b'M', b'S', b'C', 0x08, 0x00, 0x00, 0x00, 0x00, // volume label
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4F, 0x6D, 0x65, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // readme file
                b'R', b'E', b'A', b'D', b'M', b'E', b' ', b' ', b'T', b'X', b'T', 0x20, 0x00, 0xC6, 0x52, 0x6D, // readme file
                b'e', b'C', b'e', b'C', 0x00, 0x00, 0x88, 0x6D, 0x65, 0x43, 0x02, 0x00, flen, 0x00, 0x00, 0x00, // readme file
            ],
        );
        // lba3 readme file
        self.set_data(1536, readme_contents);

    }
}

impl<ReqTag: Eq + PartialEq, const LOGICAL_BLOCK_SIZE: usize, const TOTAL_DATA_SIZE: usize>
    StorageHandler<ReqTag, LOGICAL_BLOCK_SIZE>
    for RamDiskHandler<LOGICAL_BLOCK_SIZE, TOTAL_DATA_SIZE>
{
    /// Request handler
    async fn request(
        &mut self,
        request: StorageRequest<ReqTag, LOGICAL_BLOCK_SIZE>,
    ) -> StorageResponse<ReqTag, LOGICAL_BLOCK_SIZE> {
        match request.message_id {
            StorageMsgId::Setup => {
                // Setupã¯ä½•ã‚‚ã—ãªã„
                StorageResponse::report_setup_success(
                    request.req_tag,
                    TOTAL_DATA_SIZE / LOGICAL_BLOCK_SIZE,
                )
            }
            StorageMsgId::Echo => {
                // Echoã¯ä½•ã‚‚ã—ãªã„
                StorageResponse::echo(request.req_tag)
            }
            StorageMsgId::Read => {
                let mut resp = StorageResponse::read(request.req_tag, [0; LOGICAL_BLOCK_SIZE]);

                let ram_offset_start = request.lba * LOGICAL_BLOCK_SIZE;
                let ram_offset_end = ram_offset_start + LOGICAL_BLOCK_SIZE;

                if ram_offset_end > self.data.len() {
                    resp.meta_data = Some(StorageResponseMetadata::OutOfRange { lba: request.lba });
                } else {
                    // ãƒ‡ãƒ¼ã‚¿ã‚’RAM Diskã‹ã‚‰ã‚³ãƒ”ãƒ¼
                    resp.data
                        .as_mut()
                        .copy_from_slice(&self.data[ram_offset_start..ram_offset_end]);
                }
                resp
            }
            StorageMsgId::Write => {
                let mut resp = StorageResponse::write(request.req_tag);

                let ram_offset_start = request.lba * LOGICAL_BLOCK_SIZE;
                let ram_offset_end = ram_offset_start + LOGICAL_BLOCK_SIZE;

                // ç¯„å›²å¤–å¿œç­”
                if ram_offset_end > self.data.len() {
                    resp.meta_data = Some(StorageResponseMetadata::OutOfRange { lba: request.lba })
                } else {
                    // ãƒ‡ãƒ¼ã‚¿ã‚’RAM Diskã«ã‚³ãƒ”ãƒ¼ã—ã¦ã‹ã‚‰å¿œç­”
                    self.data[ram_offset_start..ram_offset_end]
                        .copy_from_slice(request.data.as_ref());
                }
                // å¿œç­”
                resp
            }
            StorageMsgId::Flush => {
                // Flushã¯ä½•ã‚‚ã—ãªã„
                StorageResponse::flush(request.req_tag)
            }
        }
    }
}

```

:::

## å®Ÿè£…æ™‚ã«ãƒŸã‚¹ã—ãŸå†…å®¹

ã—ã‚‡ã†ã‚‚ãªã„ä¸å…·åˆãŒå¤šã„ãŒã€åŒã˜ã‚ˆã†ãªã“ã¨ã‚’ã—ã‚ˆã†ã¨/ã—ã¦ã„ã‚‹äººãŒã„ãŸã¨ãã®ãŸã‚ã«æ›¸ãæ®‹ã™ã€‚

- Read (10)ã® DataOut æ™‚ã€ä¸€åº¦ã« 512byte è»¢é€ã—ã‚ˆã†ã¨ã—ã¦ Endpoint Error
- Read Capacity ã§ Last Logical Block Address ã« Num of Block ç›¸å½“ã®å€¤ã‚’å ±å‘Šã—ã¦ã„ãŸ (Device å†…éƒ¨ã®æœ€å¤§ LBA+1block ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒé£›ã‚“ã§ãã¦æ°—ãŒã¤ã„ãŸ)
- å†…éƒ¨ã® Channel ã« Read/Write è¦æ±‚ã‚’æµã™éš›ã« transfer_length åˆ†ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆåŠ ç®—å¿˜ã‚Œ
- async é–¢æ•°ã® await å‘¼ã³å¿˜ã‚Œ (Read (10) ã®å†…éƒ¨è¦æ±‚ã‚’æŠ•ã’ãšã«å¿œç­”ã‚’å¾…ã£ã¦ã„ãŸ)

ãƒ‡ãƒãƒƒã‚°æ™‚ã¯ USBPCap ã®ã‚ªãƒ—ã‚·ãƒ§ãƒ³å…¥ã‚Šã§ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸ Wireshark ãŒã‚ã‚‹ã¨æ—ã‚‹ã€‚

![wireshark.png](/images/a57b29bd9acd84/wireshark.png)
